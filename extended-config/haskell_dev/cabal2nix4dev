#!/bin/sh
# <http://redsymbol.net/articles/unofficial-bash-strict-mode/>
set -euo pipefail
IFS=$'\n\t'

die() {
    printf "$@" >&2
    exit 2
}

ensuresingle() {
    case "${#@}" in
        1)  die 'No %s found\n' "$1";;
        2)  return 0;;
        *)  die 'More than one %s found: %s\n' "$1" "${*:2}";;
    esac
}


f_cabal=(*.cabal)
ensuresingle '*.cabal' "${f_cabal[@]}"

n_package="$(grep -iE '^name:' "$f_cabal" | sed -e 's/  */\t/' | cut -f 2)"
if [[ -z "$n_package" ]] ; then die "Can't find cabal project name\n" ; fi

banner='# This file was auto-generated by cabal2nix4dev. Please do NOT edit manually!'

{
    printf '%s\n\n%s\n%s\n  %s\n' "$banner" \
        '{ haskellPackages ? (import <nixpkgs> {}).haskellPackages }:' \
        'let' 'inherit (haskellPackages)'
    cabal2nix --sha256=deleteme "$f_cabal" |
    perl -ne '
        use warnings;
        sub init {
            if (/{/) {
                &header || \&header;
                # When the list of packages fits on a single line,
                # "{" and "}" will be on the same line,
                # so handle that correctly by allowing &header to give the result
            }
        }
        sub header {
            push @v, $_;
            if (/}/) {
                print (grep { /\S/ } map { s/[\{\},:]//g; "   $_" } @v);
                print "    ;\n";
                \&deriv;
            }
        }
        sub deriv {
            s<^cabal><in cabal>;
            s<\bsha256\s*=.*;><src = ./.;>;
            print;
            \&deriv;
        }
        BEGIN { $s = \&init }
        $s = &$s || $s;
    '
} >default.nix

cat <<EOF >shell.nix
$banner

{ haskellPackages ? (import <nixpkgs> {}).haskellPackages }:

let
  pkgs = import <nixpkgs> {};
  hspkgs = haskellPackages.override {
    extension = self: super: {
      $n_package = self.callPackage ./. {
        haskellPackages = hspkgs;
      };
    };
  };

in pkgs.lib.overrideDerivation hspkgs.$n_package (attrs: {
     buildInputs = [ hspkgs.cabalInstall ] ++ attrs.buildInputs;
   })
EOF
